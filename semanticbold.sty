%% semanticbold.sty — Semantic Boldness for Numeric Tables (40–40–20)
%%
%% This project was implemented by Elchin Hasanov based on requirements
%% provided by Prof. Mingfeng Lin, Scheller College of Business, Georgia Tech.
%%
%% User API:
%%   \begin{semanticbold} ... \end{semanticbold}
%%   \SBnum{<number>}
%%   \SBsetSplit{reg}{bold}{extra}
%%
%% The three \SBsetSplit arguments are weights for the numeric range
%% bands (regular / bold / extra-bold). They do not need to sum to 100.

\RequirePackage{expl3}
\RequirePackage{xparse}

\ExplSyntaxOn

% -------- Data holders ----------
\seq_new:N \g_sb_values_seq        % all numbers collected
\int_new:N \g_sb_low_int           % numeric threshold between regular / bold
\int_new:N \g_sb_high_int          % numeric threshold between bold / extra

% Weights for each band (regular / bold / extra)
\int_new:N \g_sb_reg_w_int
\int_new:N \g_sb_bold_w_int
\int_new:N \g_sb_extra_w_int
\int_new:N \g_sb_total_w_int       % sum of weights

% Default: 40 / 40 / 20
\int_gset:Nn \g_sb_reg_w_int   { 40 }
\int_gset:Nn \g_sb_bold_w_int  { 40 }
\int_gset:Nn \g_sb_extra_w_int { 20 }
\int_gset:Nn \g_sb_total_w_int { 40 + 40 + 20 }

% Scratch registers
\seq_new:N \l_sb_sorted_seq
\int_new:N \l_sb_len_int
\int_new:N \l_sb_min_int
\int_new:N \l_sb_max_int
\int_new:N \l_sb_range_int
\int_new:N \l_sb_tmp_int
\int_new:N \l_sb_tmpb_int
\int_new:N \l_sb_tmpc_int

% -------- User command: set full split ----------
% \SBsetSplit{reg}{bold}{extra}
% The three numbers are treated as weights; they don't need to sum to 100.
\cs_new_protected:Npn \sb_set_split:nnn #1#2#3
  {
    % Clamp each to >= 0
    \int_set:Nn \l_sb_tmp_int {#1}
    \int_compare:nNnTF { \l_sb_tmp_int } < { 0 }
      { \int_set:Nn \l_sb_tmp_int { 0 } } {}

    \int_set:Nn \l_sb_tmpb_int {#2}
    \int_compare:nNnTF { \l_sb_tmpb_int } < { 0 }
      { \int_set:Nn \l_sb_tmpb_int { 0 } } {}

    \int_set:Nn \l_sb_tmpc_int {#3}
    \int_compare:nNnTF { \l_sb_tmpc_int } < { 0 }
      { \int_set:Nn \l_sb_tmpc_int { 0 } } {}

    % Total weight
    \int_set:Nn \g_sb_total_w_int
      { \l_sb_tmp_int + \l_sb_tmpb_int + \l_sb_tmpc_int }

    % If total is zero, fall back to default 40/40/20
    \int_compare:nNnTF { \g_sb_total_w_int } = { 0 }
      {
        \int_gset:Nn \g_sb_reg_w_int   { 40 }
        \int_gset:Nn \g_sb_bold_w_int  { 40 }
        \int_gset:Nn \g_sb_extra_w_int { 20 }
        \int_gset:Nn \g_sb_total_w_int { 40 + 40 + 20 }
      }
      {
        % Store user-provided weights
        \int_gset_eq:NN \g_sb_reg_w_int   \l_sb_tmp_int
        \int_gset_eq:NN \g_sb_bold_w_int  \l_sb_tmpb_int
        \int_gset_eq:NN \g_sb_extra_w_int \l_sb_tmpc_int
      }
  }

\NewDocumentCommand{\SBsetSplit}{mmm}
  { \sb_set_split:nnn{#1}{#2}{#3} }

% -------- First pass: collect numbers ----------
\cs_new_protected:Npn \sb_collect:n #1
  { \seq_gput_right:Nn \g_sb_values_seq { \int_eval:n{#1} } }

% -------- Compute numeric thresholds ----------
\cs_new_protected:Npn \sb_compute:
  {
    % Copy and sort ascending
    \seq_set_eq:NN \l_sb_sorted_seq \g_sb_values_seq
    \seq_sort:Nn \l_sb_sorted_seq
      {
        \int_compare:nNnTF {##1} > {##2}
          { \sort_return_swapped: }
          { \sort_return_same: }
      }

    \int_set:Nn \l_sb_len_int { \seq_count:N \l_sb_sorted_seq }

    \int_compare:nNnTF { \l_sb_len_int } = { 0 }
      {
        % No data
        \int_gzero:N \g_sb_low_int
        \int_gzero:N \g_sb_high_int
      }
      {
        % min & max from sorted sequence
        \int_set:Nn \l_sb_min_int { \seq_item:Nn \l_sb_sorted_seq {1} }
        \int_set:Nn \l_sb_max_int { \seq_item:Nn \l_sb_sorted_seq {\l_sb_len_int} }

        % numeric range
        \int_set:Nn \l_sb_range_int { \l_sb_max_int - \l_sb_min_int }

        % If all values equal, range = 0; everyone will fall into the top band.
        %
        % Thresholds:
        %   low  = min + (reg_w / total_w) * range
        %   high = min + ((reg_w + bold_w) / total_w) * range
        \int_gset:Nn \g_sb_low_int
          { \l_sb_min_int + \g_sb_reg_w_int * \l_sb_range_int / \g_sb_total_w_int }

        \int_gset:Nn \g_sb_high_int
          { \l_sb_min_int
            + ( \g_sb_reg_w_int + \g_sb_bold_w_int )
              * \l_sb_range_int / \g_sb_total_w_int }
      }
  }

% -------- Extra-bold effect ----------
\cs_new_protected:Npn \SBextrabold #1
  {
    \begingroup
      \setbox0=\hbox{\textbf{#1}}%
      \leavevmode\rlap{\copy0}\kern0.08em\copy0
    \endgroup
  }

% -------- Second pass: apply style ----------
\cs_new_protected:Npn \sb_typeset:n #1
  {
    \int_set:Nn \l_sb_tmp_int {#1}

    % bottom band (regular)
    \int_compare:nNnTF { \l_sb_tmp_int } < { \g_sb_low_int }
      { #1 }
      {
        % middle band (bold)
        \int_compare:nNnTF { \l_sb_tmp_int } < { \g_sb_high_int }
          { \textbf{#1} }
          { \SBextrabold{#1} } % top band
      }
  }

% Default outside environment: just print numbers
\cs_new_protected:Npn \SBnum #1 { #1 }

% -------- Two-pass environment ----------
\NewDocumentEnvironment{semanticbold}{+b}
  {
    \group_begin:
      \seq_gclear:N \g_sb_values_seq

      % FIRST PASS: collect
      \cs_set_protected:Npn \SBnum ##1 { \sb_collect:n{##1} }
      \setbox0=\vbox{#1}

      % Compute thresholds
      \sb_compute:

      % SECOND PASS: actual typesetting
      \cs_set_protected:Npn \SBnum ##1 { \sb_typeset:n{##1} }
      #1
  }
  { \group_end: }

\ExplSyntaxOff

%% End of semanticbold.sty
